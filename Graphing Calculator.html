<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Graphing Calculator</title>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CRTYR8VCRG"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-CRTYR8VCRG');
  </script>

  <!-- Google AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5494314750287277"
     crossorigin="anonymous"></script>

  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #1e1e2f;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
    }
    h1 {
      margin-bottom: 1rem;
    }
    #graph {
      border: 1px solid #444;
      border-radius: 12px;
      background-color: white;
      cursor: crosshair;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
    }
    #controls {
      margin-top: 1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }
    #top-row {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
    }
    input {
      width: 400px;
      max-width: 90vw;
      padding: 8px;
      font-size: 1rem;
      border-radius: 8px;
      border: none;
      outline: none;
    }
    button {
      padding: 8px 14px;
      font-size: 0.95rem;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      background-color: #3a3a5c;
      color: white;
      transition: background-color 0.2s ease, transform 0.1s ease, opacity 0.2s ease;
    }
    button:hover:not(:disabled) {
      background-color: #54548a;
      transform: translateY(-1px);
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    #coords {
      margin-top: 0.5rem;
      color: #ccc;
      font-size: 0.9rem;
    }
    #intersectionResult {
      margin-top: 0.25rem;
      font-size: 0.9rem;
      color: #ffd966;
      min-height: 1.2em;
    }
    #hint {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      color: #aaa;
      text-align: center;
      max-width: 600px;
    }
  </style>
</head>
<body>
  <h1>Graphing Calculator</h1>
  <canvas id="graph" width="800" height="600"></canvas>
  <div id="coords">x: 0.00, y: 0.00</div>

  <div id="controls">
    <div id="top-row">
      <input
        id="expression"
        placeholder='Enter expression (e.g. y=sinx,cosx or x^2,lnx)'
      />
      <button id="modeBtn">Mode: Radians</button>
      <button id="intersectionBtn" disabled>Define Intersection</button>
    </div>
    <div id="intersectionResult"></div>
    <div id="hint">
      • To graph multiple functions, you can use <b>y=</b> or <b>f(x)=</b>, or just separate functions with commas.<br />
      • Parent forms like <b>sinx, cosx, tanx, logx, lnx, sqrtx</b> are allowed and treated as the standard functions.<br />
      • Use the mode button to switch between <b>radians</b> and <b>degrees</b> for trig.
    </div>
  </div>

  <script>
    const canvas = document.getElementById('graph');
    const ctx = canvas.getContext('2d');
    const exprInput = document.getElementById('expression');
    const coordsDisplay = document.getElementById('coords');
    const intersectionBtn = document.getElementById('intersectionBtn');
    const intersectionResult = document.getElementById('intersectionResult');
    const modeBtn = document.getElementById('modeBtn');

    let offsetX = 0;
    let offsetY = 0;
    let scale = 40; // pixels per 1 unit
    let dragging = false;
    let dragStart = { x: 0, y: 0 };

    let useDegrees = false;

    let functions = [];          // normalized expression strings
    let compiledFunctions = [];  // functions of (x, DEG)
    let intersections = [];      // cached intersections for first two functions

    function screenToWorld(px, py) {
      return {
        x: (px - canvas.width / 2 - offsetX) / scale,
        y: (canvas.height / 2 + offsetY - py) / scale,
      };
    }

    function worldToScreen(x, y) {
      return {
        px: canvas.width / 2 + x * scale + offsetX,
        py: canvas.height / 2 - y * scale + offsetY,
      };
    }

    // Normalize expression: remove spaces, parent shorthand, implicit multiplication, and xxx -> x^3 etc.
    function normalizeExpr(input) {
      let s = input.replace(/\s+/g, '');

      // Parent forms like sinx, cosx, tanx, logx, lnx, sqrtx
      s = s
        .replace(/sinx/g, 'sin(x)')
        .replace(/cosx/g, 'cos(x)')
        .replace(/tanx/g, 'tan(x)')
        .replace(/logx/g, 'log(x)')
        .replace(/lnx/g, 'ln(x)')
        .replace(/sqrtx/g, 'sqrt(x)');

      // xxx -> x^3, xx -> x^2, etc.
      s = s.replace(/x{2,}/g, match => 'x^' + match.length);

      // Implicit multiplication:
      // number followed by x or (
      s = s.replace(/(\d)(x|\()/g, '$1*$2');
      // x or ) followed by number, x, or (
      s = s.replace(/(x|\))(\d|x|\()/g, '$1*$2');

      return s;
    }

    // Convert to JS-usable expression (Math.*, ^ -> **, ln->log, handle degrees/radians for trig)
    function replaceMathFunctions(input, useDegrees) {
      let expr = input;

      // ln(...) -> log(...)
      expr = expr.replace(/\bln\(/g, 'log(');

      const DEG_WRAP = useDegrees;

      // Handle sin, cos, tan with degree/radian option
      function handleTrig(fnName) {
        const regex = new RegExp(fnName + '\\(([^()]*)\\)', 'g');
        expr = expr.replace(regex, (match, inner) => {
          if (DEG_WRAP) {
            return `Math.${fnName}((` + inner + `)*DEG)`;
          } else {
            return `Math.${fnName}(` + inner + `)`;
          }
        });
      }

      handleTrig('sin');
      handleTrig('cos');
      handleTrig('tan');

      // Other Math.* functions
      expr = expr
        .replace(/\b(log|sqrt|abs|exp|asin|acos|atan)\b/g, 'Math.$1')
        .replace(/\bln\b/g, 'Math.log') // just in case bare ln appears
        .replace(/\^/g, '**');

      return expr;
    }

    // Parse input: handle y=/f(x)=, or plain comma-separated functions
    function parseInput() {
      const raw = exprInput.value.trim();
      if (!raw) return [];

      const lower = raw.toLowerCase();
      let rhs = null;
      const idxY = lower.indexOf('y=');
      const idxF = lower.indexOf('f(x)=');

      if (idxY !== -1) {
        rhs = raw.slice(idxY + 2);
      } else if (idxF !== -1) {
        rhs = raw.slice(idxF + 5);
      }

      if (rhs !== null) {
        return rhs
          .split(',')
          .map(s => s.trim())
          .filter(s => s.length > 0);
      }

      // No y=/f(x)= -> allow multiple via commas as well
      if (raw.includes(',')) {
        return raw
          .split(',')
          .map(s => s.trim())
          .filter(s => s.length > 0);
      }

      // Single expression
      return [raw];
    }

    function drawAxes() {
      ctx.strokeStyle = '#eee';
      ctx.lineWidth = 1;
      ctx.beginPath();

      const step = scale;

      // Grid lines
      for (let x = -canvas.width; x <= canvas.width * 2; x += step) {
        const xPos = Math.round(canvas.width / 2 + x + offsetX);
        ctx.moveTo(xPos, 0);
        ctx.lineTo(xPos, canvas.height);
      }

      for (let y = -canvas.height; y <= canvas.height * 2; y += step) {
        const yPos = Math.round(canvas.height / 2 - y + offsetY);
        ctx.moveTo(0, yPos);
        ctx.lineTo(canvas.width, yPos);
      }

      ctx.stroke();

      // X and Y axes
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 2;
      ctx.beginPath();
      // x-axis
      ctx.moveTo(0, canvas.height / 2 + offsetY);
      ctx.lineTo(canvas.width, canvas.height / 2 + offsetY);
      // y-axis
      ctx.moveTo(canvas.width / 2 + offsetX, 0);
      ctx.lineTo(canvas.width / 2 + offsetX, canvas.height);
      ctx.stroke();
    }

    function clearCanvas() {
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function plot() {
      clearCanvas();
      drawAxes();

      const colors = ['blue', 'red', 'green', 'purple', 'orange', 'brown'];
      const DEG = useDegrees ? Math.PI / 180 : 1;

      compiledFunctions.forEach((fn, index) => {
        if (typeof fn !== 'function') return;

        ctx.beginPath();
        ctx.strokeStyle = colors[index % colors.length];
        ctx.lineWidth = 2;

        let first = true;
        let prevY = null;

        for (let px = 0; px <= canvas.width; px++) {
          const world = screenToWorld(px, 0);
          const x = world.x;

          let y;
          try {
            y = fn(x, DEG);
          } catch (e) {
            y = NaN;
          }

          if (!isFinite(y) || Math.abs(y) > 1e6) {
            first = true;
            prevY = null;
            continue;
          }

          const py = canvas.height / 2 - y * scale + offsetY;

          // avoid drawing across vertical asymptotes (tan, etc.)
          if (
            prevY !== null &&
            Math.abs(py - (canvas.height / 2 - prevY * scale + offsetY)) >
              canvas.height
          ) {
            first = true;
          }

          if (first) {
            ctx.moveTo(px, py);
            first = false;
          } else {
            ctx.lineTo(px, py);
          }

          prevY = y;
        }

        ctx.stroke();
      });

      // Draw intersections (if any)
      if (intersections.length > 0) {
        ctx.fillStyle = 'black';
        intersections.forEach(pt => {
          const { px, py } = worldToScreen(pt.x, pt.y);
          ctx.beginPath();
          ctx.arc(px, py, 4, 0, Math.PI * 2);
          ctx.fill();
        });
      }
    }

    function updateFunctions() {
      const parsed = parseInput();
      functions = parsed.map(normalizeExpr);

      compiledFunctions = functions.map(str => {
        const js = replaceMathFunctions(str, useDegrees);
        try {
          return new Function('x', 'DEG', 'return ' + js);
        } catch (e) {
          return null;
        }
      });

      intersections = [];
      intersectionResult.textContent = '';
      intersectionBtn.disabled =
        compiledFunctions.length < 2 ||
        compiledFunctions.some(fn => typeof fn !== 'function');

      plot();
    }

    // Find intersections between first two functions
    function findIntersections() {
      const pts = [];
      if (compiledFunctions.length < 2) return pts;
      const f1 = compiledFunctions[0];
      const f2 = compiledFunctions[1];
      if (typeof f1 !== 'function' || typeof f2 !== 'function') return pts;

      const maxPx = canvas.width;
      let prev = null;
      const DEG = useDegrees ? Math.PI / 180 : 1;

      for (let px = 0; px <= maxPx; px++) {
        const { x } = screenToWorld(px, 0);
        let y1, y2;
        try {
          y1 = f1(x, DEG);
          y2 = f2(x, DEG);
        } catch (e) {
          prev = null;
          continue;
        }

        if (!isFinite(y1) || !isFinite(y2)) {
          prev = null;
          continue;
        }

        const diff = y1 - y2;

        if (prev && diff * prev.diff <= 0) {
          const root = bisect(f1, f2, prev.x, x, 25, DEG);
          if (root !== null) {
            const yi = f1(root, DEG);
            if (isFinite(yi)) {
              const already = pts.some(
                p =>
                  Math.abs(p.x - root) < 1e-3 &&
                  Math.abs(p.y - yi) < 1e-3
              );
              if (!already) {
                pts.push({ x: root, y: yi });
              }
            }
          }
        }

        prev = { x, diff };
      }

      return pts;
    }

    function bisect(f1, f2, a, b, steps, DEG) {
      let fa, fb;
      try {
        fa = f1(a, DEG) - f2(a, DEG);
        fb = f1(b, DEG) - f2(b, DEG);
      } catch (e) {
        return null;
      }
      if (!isFinite(fa) || !isFinite(fb) || fa * fb > 0) return null;

      let left = a;
      let right = b;

      for (let i = 0; i < steps; i++) {
        const mid = 0.5 * (left + right);
        let fm;
        try {
          fm = f1(mid, DEG) - f2(mid, DEG);
        } catch (e) {
          return null;
        }
        if (!isFinite(fm)) return null;

        if (fa * fm <= 0) {
          right = mid;
          fb = fm;
        } else {
          left = mid;
          fa = fm;
        }
      }

      return 0.5 * (left + right);
    }

    // Expression input
    exprInput.addEventListener('input', () => {
      updateFunctions();
    });

    // Intersection button
    intersectionBtn.addEventListener('click', () => {
      intersections = findIntersections();

      if (intersections.length === 0) {
        intersectionResult.textContent = 'Functions Do Not Intersect';
      } else {
        const text = intersections
          .map(p => `(${p.x.toFixed(2)}, ${p.y.toFixed(2)})`)
          .join(', ');
        intersectionResult.textContent = 'Intersections: ' + text;
      }

      plot();
    });

    // Degrees/radians mode toggle
    modeBtn.addEventListener('click', () => {
      useDegrees = !useDegrees;
      modeBtn.textContent = useDegrees ? 'Mode: Degrees' : 'Mode: Radians';
      updateFunctions();
    });

    // Panning
    canvas.addEventListener('mousedown', e => {
      dragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
    });

    canvas.addEventListener('mouseup', () => {
      dragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
      dragging = false;
    });

    canvas.addEventListener('mousemove', e => {
      if (dragging) {
        offsetX += e.clientX - dragStart.x;
        offsetY += e.clientY - dragStart.y;
        dragStart = { x: e.clientX, y: e.clientY };
        plot();
      }

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const world = screenToWorld(x, y);
      coordsDisplay.textContent = `x: ${world.x.toFixed(
        2
      )}, y: ${world.y.toFixed(2)}`;
    });

    // Zooming
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const zoomIntensity = 1.1;
      const mouseWorld = screenToWorld(e.offsetX, e.offsetY);
      const prevScale = scale;

      if (e.deltaY < 0) {
        scale *= zoomIntensity;
      } else {
        scale /= zoomIntensity;
      }

      offsetX += mouseWorld.x * prevScale - mouseWorld.x * scale;
      offsetY += -mouseWorld.y * prevScale + mouseWorld.y * scale;

      plot();
    });

    // Initial setup
    exprInput.value = 'y=x*x';
    updateFunctions();
  </script>
</body>
</html>
